<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
  

<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="shortcut icon" type="image/png" href="http://localhost:1313/favicon.ico" />
<meta property="og:url" content="http://localhost:1313/posts/hrtimer-cve-2026-23014/">
  <meta property="og:site_name" content="Will Rosenberg">
  <meta property="og:title" content="n-day exploit of CVE-2026-23014">
  <meta property="og:description" content="Linux kernel exploitation of CVE-2026-23014">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2026-02-15T12:00:00+00:00">
    <meta property="article:modified_time" content="2026-02-15T12:00:00+00:00">
    <meta property="article:tag" content="Kernel">
    <meta property="article:tag" content="Exploitation">

<title>Will Rosenberg | n-day exploit of CVE-2026-23014</title>

    <link rel="stylesheet" href="/css/main.css">
  
      <link rel="stylesheet" href="/css/palette/eink.css">

      <script src="/js/main.js"></script>

<link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH" crossorigin="anonymous">

</head>

  
<body
    class="dark"
>
  
  <main>
    
  <div class="container pt-5">
    <div class="row mt-5 pt-5">
      
  <nav aria-label="breadcrumb" class="small">
    <ol class="breadcrumb fw-bold">
    <li class="breadcrumb-item">
      <a href="/"
        
      >home</a>
      
    </li>
    <li class="breadcrumb-item">
      <a href="/posts"
        class="text-decoration-underline link-offset-3"
        
      >posts</a>
      
    </li>
    <li class="breadcrumb-item">
      <a href="/cv.pdf"
        
      >cv</a>
      
    </li>
    <li class="breadcrumb-item">
      <a href="/#contact"
        
      >contact</a>
      
    </li>
    </ol>
  </nav>

    </div>
    
    <div class="post">
      <header class="mb-4">
        <h1 class="text-uppercase">n-day exploit of CVE-2026-23014</h1>
        
        
        <div aria-label="breadcrumb">
          <ol class="breadcrumb">
            <li class="breadcrumb-item small">
              
              <time datetime="2026-02-15T12:00:00&#43;00:00">February 15, 2026</time>
            </li>
            
            
            <li class="breadcrumb-item small">
              16 minutes
            </li>
          </ol>
        </div>
      </header>
      <article>
        <h1 id="preamble">Preamble</h1>
<p>A little less than 2 months ago, I found what was, at the time, a 0-day vulnerability in the Linux kernel. I decided it was too recent a bug to get any money from exploiting and ended up reporting it to the Linux kernel developers. After getting ignored by the Linux kernel developers for a month, I decided to try and exploit it, only to realize it had been patched a few weeks after my initial bug report.</p>
<p>Nonetheless, I thought it would be a fun exercise to exploit it and achieve LPE with an n-day exploit. I am exploiting against v6.18.5 with KernelCTF&rsquo;s <a href="https://cos.googlesource.com/third_party/kernel/+/refs/heads/cos-6.12/arch/x86/configs/lakitu_defconfig">COS config</a>.</p>
<p>This bug is patched in all active kernel branches and never even reached most Linux distros with the main exception being rolling distros like Arch.</p>
<h1 id="the-bug">The Bug</h1>
<p>The bug in question is CVE-2026-23014. The <a href="https://git.kernel.org/pub/scm/linux/kernel/git/stable/linux.git/commit/?id=deee9dfb111ab00f9dfd46c0c7e36656b80f5235">patch commit message</a> incorrectly details the root cause and introducing commit but fortunately/unfortunately, correctly patches the bug.</p>
<p>This bug exists in the performance event subsystem in <code>perf_swevent_cancel_hrtimer()</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">/*
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * Careful: this function can be triggered in the hrtimer handler,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * for cpu-clock events, so hrtimer_cancel() would cause a
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * deadlock.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> *
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * So use hrtimer_try_to_cancel() to try to stop the hrtimer,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * and the cpu-clock handler also sets the PERF_HES_STOPPED flag,
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * which guarantees that perf_swevent_hrtimer() will stop the
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> * hrtimer once it sees the PERF_HES_STOPPED flag.
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">is_sampling_event</span>(event) <span style="color:#f92672">&amp;&amp;</span> (hwc<span style="color:#f92672">-&gt;</span>interrupts <span style="color:#f92672">!=</span> MAX_INTERRUPTS)) {
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">hrtimer_try_to_cancel</span>(<span style="color:#f92672">&amp;</span>hwc<span style="color:#f92672">-&gt;</span>hrtimer);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>The check <code>hwc-&gt;interrupts != MAX_INTERRUPTS</code> prevents the high resolution timer (<code>hrtimer</code>), used for periodic sampling of certain software events, from being directly canceled when the software event is throttled. This was originally added to prevent a deadlock when trying to cancel an hrtimer within its own handler. Instead, throttled events should rely on the <code>PERF_HES_STOPPED</code> flag to trigger <code>HRTIMER_NORESTART</code> in <code>perf_swevent_hrtimer()</code>, preventing the hrtimer from being requeued. Since an hrtimer is dequeued when its handler function is running, this is an effective solution.</p>
<p>The problem arises when our hrtimer is throttled while active. This is possible through the performance event grouping mechanism, which allows for many features including shared scheduling. This means if one event in a group is throttled, all events are throttled via <code>perf_event_throttle_group()</code>. As a result, the timer can now remain in the queue after <code>perf_swevent_cancel_hrtimer()</code>.</p>
<p>This would likely not be a vulnerability, except <code>perf_swevent_cancel_hrtimer()</code> is part of the call-chain to dequeue (cancel) the hrtimer on software event destruction:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>-&gt; __perf_remove_from_context()
</span></span><span style="display:flex;"><span>    -&gt; event_sched_out()
</span></span><span style="display:flex;"><span>        -&gt; cpu_clock_event_del()
</span></span><span style="display:flex;"><span>            -&gt; cpu_clock_event_stop()
</span></span><span style="display:flex;"><span>                -&gt; perf_swevent_cancel_hrtimer()
</span></span></code></pre></div><p>All of a sudden, we have a potential UAF.</p>
<h2 id="theory---poc">Theory -&gt; PoC</h2>
<p>If we manage to throttle our target software event, we can then free the event, while the hrtimer remains in the queue. Since <code>hrtimer</code> is a  sub-struct of <code>perf_event</code>, the hrtimer reference in the timer queue points back to our now freed <code>perf_event</code>!</p>
<p>To turn theory into reality, we create an events group with our target software event and a throttling event. Our target software event must use an hrtimer, so I opted to use <code>PERF_COUNT_SW_CPU_CLOCK</code>. The hrtimer length must also be set long enough so that it does not expire and dequeue before the UAF happens. I set this value to 30 seconds, which can be controlled by setting the <code>sample_period</code> of the software event in nanoseconds.</p>
<p>For the throttling event, we use <code>PERF_COUNT_HW_CPU_CYCLES</code> with a <code>sample_period</code> of <code>1</code>. However, this does not immediately throttle our group. To throttle, the number of interrupts since the last tick must be greater than or equal to <code>max_samples_per_tick</code>, a global variable calculated using <code>sysctl_perf_event_sample_rate</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>static int
</span></span><span style="display:flex;"><span>__perf_event_account_interrupt(struct perf_event *event, int throttle)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	struct hw_perf_event *hwc = &amp;event-&gt;hw;    
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if (unlikely(throttle &amp;&amp; hwc-&gt;interrupts &gt;= max_samples_per_tick)) {
</span></span><span style="display:flex;"><span>		...
</span></span><span style="display:flex;"><span>        perf_event_throttle_group(event);
</span></span><span style="display:flex;"><span>    	...
</span></span><span style="display:flex;"><span>    }
</span></span></code></pre></div><p>I found that I needed <code>max_samples_per_tick &lt;= 10000</code> for reliable throttling. If we want to directly set this value, we must be root and write to <code>/proc/sys/kernel/perf_event_max_sample_rate</code>.</p>
<p>Good news - this value can be lowered in <code>perf_sample_event_took()</code> if the average perf event nmi handler length is too high. Don&rsquo;t worry, the rabbit-hole doesn&rsquo;t go too deep. Increasing the average nmi handler length is as simple as having a lot of perf event sampling, i.e. spam multiple throttling events as part of the exploit setup.</p>
<p>We see this message buffer output as a result:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>perf: interrupt took too long (2587 &gt; 2500), lowering kernel.perf_event_max_sample_rate to 77000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (3251 &gt; 3233), lowering kernel.perf_event_max_sample_rate to 61000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (4255 &gt; 4063), lowering kernel.perf_event_max_sample_rate to 47000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (5362 &gt; 5318), lowering kernel.perf_event_max_sample_rate to 37000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (6721 &gt; 6702), lowering kernel.perf_event_max_sample_rate to 29000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (8483 &gt; 8401), lowering kernel.perf_event_max_sample_rate to 23000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (10637 &gt; 10603), lowering kernel.perf_event_max_sample_rate to 18000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (13426 &gt; 13296), lowering kernel.perf_event_max_sample_rate to 14000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (16787 &gt; 16782), lowering kernel.perf_event_max_sample_rate to 11000
</span></span><span style="display:flex;"><span>perf: interrupt took too long (20990 &gt; 20983), lowering kernel.perf_event_max_sample_rate to 9000
</span></span></code></pre></div><h2 id="unprivileged-access">Unprivileged Access</h2>
<p>The performance subsystem has different levels of unprivileged access according to <code>perf_event_paranoid</code>. From the <a href="https://www.kernel.org/doc/Documentation/sysctl/kernel.txt">kernel developers</a>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Controls use of the performance events system by unprivileged
</span></span><span style="display:flex;"><span>users (without CAP_SYS_ADMIN).  The default value is 2.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> -1: Allow use of (almost) all events by all users
</span></span><span style="display:flex;"><span>     Ignore mlock limit after perf_event_mlock_kb without CAP_IPC_LOCK
</span></span><span style="display:flex;"><span>&gt;=0: Disallow ftrace function tracepoint by users without CAP_SYS_ADMIN
</span></span><span style="display:flex;"><span>     Disallow raw tracepoint access by users without CAP_SYS_ADMIN
</span></span><span style="display:flex;"><span>&gt;=1: Disallow CPU event access by users without CAP_SYS_ADMIN
</span></span><span style="display:flex;"><span>&gt;=2: Disallow kernel profiling by users without CAP_SYS_ADMIN
</span></span></code></pre></div><p>Debian, Ubuntu, and Android kernels introduce another security level <code>PERF_SECURITY_TRACEPOINT = 3</code>, and Ubuntu introduces <code>PERF_SECURITY_MAX = 4</code> as the default, preventing any unprivileged performance events :\</p>
<p>Ubuntu source:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#75715e">#define PERF_SECURITY_OPEN		    0
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">/* Finer grained perf_event_open(2) access control. */</span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#define PERF_SECURITY_CPU	        1
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PERF_SECURITY_KERNEL		2
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PERF_SECURITY_TRACEPOINT	3
</span></span></span><span style="display:flex;"><span><span style="color:#75715e">#define PERF_SECURITY_MAX		    4
</span></span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">inline</span> <span style="color:#66d9ef">bool</span> <span style="color:#a6e22e">perf_paranoid_any</span>(<span style="color:#66d9ef">void</span>)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">return</span> sysctl_perf_event_paranoid <span style="color:#f92672">&gt;=</span> PERF_SECURITY_MAX;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This means our bug is not triggerable from unprivileged users on Ubuntu but should work for other default distros. We just have to include <code>.exclude_kernel = 1</code> and only track the current process when creating our performance events. There is also <code>.exclude_hv</code> for hypervisor events, but this does not apply to the chosen events.</p>
<h1 id="exploit-time">Exploit Time</h1>
<p>We got an unprivileged UAF! Now what?</p>
<p>Well, first, we should probably understand what an <code>hrtimer</code> even is and how it fits into our <code>perf_event</code>. <code>perf_event</code> is a large struct, but importantly it contains: <code>struct hw_perf_event hw</code>, which internally contains <code>struct hrtimer hrtimer</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> hrtimer {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> timerqueue_node		node;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">ktime_t</span>				_softexpires;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">hrtimer_restart</span>		(<span style="color:#f92672">*</span>__private function)(<span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> hrtimer_clock_base	<span style="color:#f92672">*</span>base;
</span></span><span style="display:flex;"><span>	u8				state;
</span></span><span style="display:flex;"><span>	u8				is_rel;
</span></span><span style="display:flex;"><span>	u8				is_soft;
</span></span><span style="display:flex;"><span>	u8				is_hard;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>Great news! We have a function pointer in our struct. This means if we can control its contents, we can almost certainly get PC control and win. We will delve MUCH deeper into the hrtimer rabbit-hole in a bit, but for now, this is all we need to know about them.</p>
<h2 id="cross-cache">Cross-cache</h2>
<p>Since <code>perf_event</code> has its own SLUB cache, I opted to use the cross-cache technique to overlap a <code>struct msg_msg</code> to control the data. This <a href="https://ruia-ruia.github.io/2022/08/05/CVE-2022-29582-io-uring">article</a> does a great job explaining the underlying mechanics, but I opted for the simpler spray and pray method described <a href="https://kaligulaarmblessed.github.io/post/cross-cache-for-lazy-people/">here</a>.</p>
<p>As a quick note, from here on out, the exploit code is pinned to the same CPU core since many kernel mechanisms have per-cpu components.</p>
<p>The only question we need to answer is what size should our message be? As mentioned in the first linked article, the buddy allocator does not treat all pages the same. It distinguishes between the order of pages, where higher order pages represent larger continuous regions of memory. For simplicity, we should choose a message size such that the <code>struct msg_msg</code> cache has the same page order as the <code>perf_event</code> cache. Using <code>/proc/slabinfo</code>, we want the <code>pagesperslab</code> to match:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># name            &lt;active_objs&gt; &lt;num_objs&gt; &lt;objsize&gt; &lt;objperslab&gt; &lt;pagesperslab&gt;
</span></span><span style="display:flex;"><span>perf_event            12     12   1344   12    4
</span></span><span style="display:flex;"><span>msg_msg-1k             0      0   1024   16    4
</span></span></code></pre></div><p>Since <code>CONFIG_SLAB_BUCKETS</code> is enabled, <code>msg_msg</code> has its own cache - another reason cross-cache is so great. Although, it should be noted that on the kernelctf mitigation instance, cross-cache is thwarted by <code>SLAB_VIRTUAL</code>.</p>
<p>We see the value is 4 pages per slab for <code>perf_event</code>, and the matching <code>msg_msg</code> cache corresponds to a size of 1024. Since there is an overhead of 0x48, I allocate a msg of size 976.</p>
<p>The final step before we get arbitrary control of the hrtimer data is to determine how <code>hrtimer</code> and <code>msg_msg</code> overlap to calculate offsets. Normally, this is pretty trivial, but <code>perf_event</code> goes across page boundaries, so depending on which object we get from the slab freelist (<code>CONFIG_SLAB_FREELIST_RANDOM</code>), the offset of <code>hrtimer</code> from the beginning of <code>msg_msg</code> can vary:</p>
<p><img src="images/memory_layout.png" alt="Memory layout diagram"></p>
<p>Fortunately, these regions are non-intersecting, so we can craft a <code>msg_msg</code> such that it writes the same content to <code>hrtimer</code> no matter which <code>perf_event</code> we get from the slab freelist. The one caveat is that one <code>hrtimer</code> region (0x3e8 - 0x28) wraps around <code>msg_msg</code>. Since there is a 0x48 overhead, I opted to just take the loss and call 11 out of 12 good enough.</p>
<p>However, even this is likely solvable. If we use <code>msg_seg</code>, there is only an 8 byte overhead, which would only corrupt the <code>timerqueue_node</code> <code>expires</code> field. As will become clearer later, this is not the end of the world. The exploit should still work with potential timing issues, but for simplicity and proof of exploit, I will ignore this edge case.</p>
<h2 id="hrtimer--win">hrtimer = win?</h2>
<p>Arbitrary <code>hrtimer</code> data achieved! With the function pointer, a win should be trivial right?</p>
<p>Kinda.</p>
<p>We still never discussed how this function pointer is used. As a reminder:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> hrtimer {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> timerqueue_node		node;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">ktime_t</span>				_softexpires;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">hrtimer_restart</span>		(<span style="color:#f92672">*</span>__private function)(<span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span>);
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> hrtimer_clock_base	<span style="color:#f92672">*</span>base;
</span></span><span style="display:flex;"><span>	u8				state;
</span></span><span style="display:flex;"><span>	u8				is_rel;
</span></span><span style="display:flex;"><span>	u8				is_soft;
</span></span><span style="display:flex;"><span>	u8				is_hard;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> timerqueue_node {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node node;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">ktime_t</span> expires;
</span></span><span style="display:flex;"><span>};
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">struct</span> rb_node {
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span>  __rb_parent_color;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">*</span>rb_right;
</span></span><span style="display:flex;"><span>	<span style="color:#66d9ef">struct</span> rb_node <span style="color:#f92672">*</span>rb_left;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>The hrtimer system works on a per-cpu basis (pointed to by <code>base</code>), where each cpu has a timerqueue holding its hrtimers. This <code>timerqueue</code> is just a red-black tree (rb-tree) ordered by the <code>expires</code> time in each node. During <code>hrtimer_interrupt()</code>, called as part of the timer interrupt, nodes are dequeued if their <code>_softexpires</code> expiration time is before or equal to the current time in nanoseconds:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">__hrtimer_run_queues</span>(<span style="color:#66d9ef">struct</span> hrtimer_cpu_base <span style="color:#f92672">*</span>cpu_base, <span style="color:#66d9ef">ktime_t</span> now,
</span></span><span style="display:flex;"><span>				 <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">long</span> flags, <span style="color:#66d9ef">unsigned</span> <span style="color:#66d9ef">int</span> active_mask)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>    ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">while</span> ((node <span style="color:#f92672">=</span> <span style="color:#a6e22e">timerqueue_getnext</span>(<span style="color:#f92672">&amp;</span>base<span style="color:#f92672">-&gt;</span>active))) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">struct</span> hrtimer <span style="color:#f92672">*</span> timer;
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> (basenow <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">hrtimer_get_softexpires_tv64</span>(timer))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">break</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">__run_hrtimer</span>(cpu_base, base, timer, <span style="color:#f92672">&amp;</span>basenow, flags);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>When dequeued, the callback function stored in <code>timer-&gt;function</code> is called via <code>__run_hrtimer()</code>. Therefore, we need to maintain a &ldquo;valid&rdquo; hrtimer so that it can remain in the timerqueue and be properly dequeued.</p>
<p>Initially, I just set <code>expires</code> = <code>_softexpire</code> = current time + 10 seconds, the <code>u8</code> fields to the same value in the original struct, <code>function</code> to 0x1337, and the pointers to NULL. My hope was to get a kernel page fault on 0x1337 to confirm PC control. However, I immediately ran into NULL-ptr dereference panics in <code>timerqueue_add()</code> and <code>timerqueue_del()</code>.</p>
<h2 id="rb-tree-feng-shui">RB-Tree Feng Shui</h2>
<p>In this section, I will discuss how to resolve these kernel panics by manipulating our target node and the rb-tree. I will try to explain the relevant rb-tree algorithms, but you should be familiar with the <a href="https://www.geeksforgeeks.org/dsa/introduction-to-red-black-tree/">basic algorithms and invariants of rb-trees</a>.</p>
<p>At first, I was confused because all the NULL pointers should be valid. <code>base</code> will not be used unless our CPU dies and child and parent pointers can be NULL in an rb-tree. NULL child pointers indicate a leaf node, and a NULL parent pointer indicates the root of the tree. However, for efficiency, many rb-tree algorithms can make assumptions about the existence of children and parent nodes without doing a NULL check.</p>
<p>To fix this, I created a method to make the parent pointer valid:</p>
<ol>
<li>Create a timer with a slightly smaller expiration time than the target node. We will call this new timer the predecessor.</li>
<li>Insert the target node.</li>
<li>Remove the predecessor.</li>
</ol>
<p>The rb-tree removal algorithm will set the target&rsquo;s parent pointer while never using the invalid one. This works because binary search tree (BST) removal replaces the deleted node with its successor and conveniently searches down the rb-tree to find the successor. This means that efficient rb-tree implementations, such as the Linux kernel, will not access the successor&rsquo;s parent pointer when updating the tree. Instead, the parent is remembered from the initial tree traversal.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-gdscript3" data-lang="gdscript3"><span style="display:flex;"><span><span style="color:#66d9ef">static</span> __always_inline struct rb_node <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span>__rb_erase_augmented(struct rb_node <span style="color:#f92672">*</span>node, struct rb_root <span style="color:#f92672">*</span>root,
</span></span><span style="display:flex;"><span>		     <span style="color:#66d9ef">const</span> struct rb_augment_callbacks <span style="color:#f92672">*</span>augment)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>struct rb_node <span style="color:#f92672">*</span>child <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>rb_right;
</span></span><span style="display:flex;"><span>struct rb_node <span style="color:#f92672">*</span>tmp <span style="color:#f92672">=</span> node<span style="color:#f92672">-&gt;</span>rb_left;
</span></span><span style="display:flex;"><span>struct rb_node <span style="color:#f92672">*</span>parent, <span style="color:#f92672">*</span>rebalance;
</span></span><span style="display:flex;"><span>unsigned long pc;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>struct rb_node <span style="color:#f92672">*</span>successor <span style="color:#f92672">=</span> child, <span style="color:#f92672">*</span>child2;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tmp <span style="color:#f92672">=</span> child<span style="color:#f92672">-&gt;</span>rb_left;
</span></span><span style="display:flex;"><span><span style="color:#f92672">...</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">/*</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> Case <span style="color:#ae81ff">3</span>: node<span style="color:#e6db74">&#39;s successor is leftmost under</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span> node<span style="color:#e6db74">&#39;s right child subtree</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    (n)          (s)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    <span style="color:#f92672">/</span> \          <span style="color:#f92672">/</span> \
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  (x) (y)  <span style="color:#f92672">-&gt;</span>  (x) (y)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>      <span style="color:#f92672">/</span>            <span style="color:#f92672">/</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    (p)          (p)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    <span style="color:#f92672">/</span>            <span style="color:#f92672">/</span>
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>  (s)          (c)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    \
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*</span>    (c)
</span></span><span style="display:flex;"><span> <span style="color:#f92672">*/</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">do</span> {
</span></span><span style="display:flex;"><span>    parent <span style="color:#f92672">=</span> successor;
</span></span><span style="display:flex;"><span>    successor <span style="color:#f92672">=</span> tmp;
</span></span><span style="display:flex;"><span>    tmp <span style="color:#f92672">=</span> tmp<span style="color:#f92672">-&gt;</span>rb_left;
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">while</span> (tmp);
</span></span><span style="display:flex;"><span>child2 <span style="color:#f92672">=</span> successor<span style="color:#f92672">-&gt;</span>rb_right;
</span></span><span style="display:flex;"><span>WRITE_ONCE(parent<span style="color:#f92672">-&gt;</span>rb_left, child2);
</span></span></code></pre></div><p>This change improved stability, but there were still panics in the rb-tree insertion and removal algorithms. These panics mostly occurred because the parent pointer (<code>__rb_parent_color</code>) had not been fixed yet or the child pointers were NULL.</p>
<h3 id="observe-then-strike">Observe, Then Strike</h3>
<p>On insertion, if our target node becomes the parent of the now inserted node, the tree can undergo a rebalancing. This only happens when the parent node is red because if the parent node is black, no rb-tree properties are violated on insertion.</p>
<p><img src="images/rb-insertion.png" alt="Red Black Tree Insertion"></p>
<p>Made with the <a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">RedBlack Visualizer</a></p>
<p>When rebalancing, the insertion algorithm picks between one of two cases depending on whether or not the uncle of the inserted node is red or black. In either case, to check the color of the uncle, we must navigate to the grandparent (parent of our target node). Due to the root-is-black invariant of rb-trees, the grandparent must exist, meaning no NULL check is performed:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>static __always_inline void
</span></span><span style="display:flex;"><span>__rb_insert(struct rb_node *node, struct rb_root *root,
</span></span><span style="display:flex;"><span>	    void (*augment_rotate)(struct rb_node *old, struct rb_node *new))
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>        ...
</span></span><span style="display:flex;"><span>        /*
</span></span><span style="display:flex;"><span>		 * If there is a black parent, we are done.
</span></span><span style="display:flex;"><span>		 * Otherwise, take some corrective action as,
</span></span><span style="display:flex;"><span>		 * per 4), we don&#39;t want a red root or two
</span></span><span style="display:flex;"><span>		 * consecutive red nodes.
</span></span><span style="display:flex;"><span>		 */
</span></span><span style="display:flex;"><span>		if(rb_is_black(parent))
</span></span><span style="display:flex;"><span>			break;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		gparent = rb_red_parent(parent);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		tmp = gparent-&gt;rb_right;
</span></span></code></pre></div><p>This of course leads to a NULL-ptr dereference when the parent pointer is still corrupted. To fix this, we can simply make our target node black.</p>
<p>On deletion, the BST deletion algorithm swaps the deleted node with its successor, as discussed earlier. When the successor is a black node, the sibling is checked. If our target node is the parent of the successor, checking the siblings will dereference our NULL child pointers - kernel panic!</p>
<p>There is no NULL child check because the invariant that requires all node-to-leaf paths have the same number of black nodes ensures a black leaf node must have a sibling node. To fix (or at least remedy) this issue, we should make our target node black. The idea is that a red node must have a black child node, so having a black target node allows for the possibility of a red child node, avoiding the NULL-ptr deref.</p>
<p>Let&rsquo;s go! I was starting to get worried that the insertion vs deletion investigations would give conflicting results on what color our target node should be. Nonetheless, there still exists a window between the UAF and successful control of the hrtimer data where the NULL-ptr deref can happen, assuming the cross-cache ever succeeds.</p>
<p>Deeper rb-tree issues can also arise if the initial node corruption propagates into more invariant violations. There is certainly room for improvement, but overall, we have significantly limited the kernel panic issue.</p>
<h3 id="failed-experimenting">Failed Experimenting</h3>
<p>As mentioned, we did not outright solve our rb-tree corruption but rather reduced the chance a panic happens. To help prevent further rb-tree corruption, I experimented with isolating the target node from the uncontrolled rb-tree. I had two ideas:</p>
<ol>
<li>Make the target and predecessor very large (10+ minutes). This moves them to the right most side of the rb-tree, hopefully isolating the nodes. One major drawback of this approach is that our timer is now really long, and we have created a cool, but slow ticking time bomb of an exploit.</li>
<li>Insert many timers of the same length, hopefully isolating the target timer from the noise of the timerqueue.</li>
</ol>
<p><strong>Case 1:</strong> I found this technique did not significantly change the stability. I think it failed because despite being the right most node, our target node can still have child nodes, so there is little real isolation. Also, the predecessor can even become the target node&rsquo;s child, so when the predecessor is freed, the kernel can panic.</p>
<p><strong>Case 2:</strong> Again, this technique was not effective. The problem is rb-tree rebalancing is hard to predict without knowing the exact tree layout. As a result, spamming new nodes does not necessarily separate the target node from the uncontrolled nodes in the tree. I even tried combining case 1 and 2, but this failed likely for the same reasons.</p>
<p>For my final exploit, I chose to keep it simple and not use these isolation techniques since I found little benefit and could already achieve ~50% stability.</p>
<p>I would be curious if there are better techniques to significantly improve the reliability of the exploit. I wanted to avoid heap leaks, but if heap leaks are possible without introducing more instability, maybe crafting fake nodes could work.</p>
<h2 id="kaslr-is-dead">KASLR Is Dead</h2>
<p>I just used a prefetch side-channel attack to leak the kernel base. I mostly copied the code from this <a href="https://github.com/google/security-research/blob/master/pocs/linux/kernelctf/CVE-2023-6817_mitigation/exploit/mitigation-v3-6.1.55/exploit.c">writeup</a>.</p>
<h2 id="rop-to-win">ROP to Win</h2>
<p>With every piece in place, we just need to convert our arbitrary PC to code execution. I opted to use kylebot&rsquo;s <a href="https://github.com/sefcom/RetSpill">retspill</a> technique to create a ROP chain and win. In short, retspill uses the userspace general-purpose registers stored on the stack as a source of user-controlled data in kernel space to create a ROP chain. By directing our arbitrary PC to a stack pivot gadget, we can pivot to our ROP chain and perform a classic <code>commit_creds()</code> ROP chain.</p>
<p>The one caveat is that our hrtimer callback occurs in a timer interrupt. The typical retspill use case is with a syscall, where we can set the registers before calling. Timer interrupts, on the other hand, are asynchronous. To reliably get the registers on the stack, I loaded the appropriate values into the registers and then looped infinitely. I only needed one thread in my VM environment, but for a real system, one could create many threads to saturate the CPU core.</p>
<p>The timer interrupt also occurs in a hardirq context, so our ROP chain must perform <code>irq_exit()</code>. From there, we setup the proper return stack and <code>iretq</code>:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// pop rdi; ret
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// init_cred
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// commit_creds()
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// irq_exit()
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// swapgs; ret
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// iretq;
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#75715e">// rip
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x33</span>; <span style="color:#75715e">// CS
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x216</span>; <span style="color:#75715e">// RFLAGS
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> ; <span style="color:#75715e">// valid rsp
</span></span></span><span style="display:flex;"><span>rop_chain[n<span style="color:#f92672">++</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">0x2b</span>; <span style="color:#75715e">// SS
</span></span></span></code></pre></div><p>On my interrupt stack frame, I used an invalid <code>rip</code> to simplify returning to user space by triggering a SIGSEGV handler that pops a ROOT shell!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span># id
</span></span><span style="display:flex;"><span>uid=0(root) gid=0(root) groups=0(root)
</span></span><span style="display:flex;"><span># echo kernel pwned.
</span></span><span style="display:flex;"><span>kernel pwned.
</span></span><span style="display:flex;"><span>#
</span></span></code></pre></div><p>As discussed, the final exploit had a stability ~55% - determined by testing the exploit 1000 times. I think there are definitely ways to improve the stability further through more complex rb-tree feng shui, but 50% is not too bad.</p>

      </article>
      
  <div class="tags pb-4 pt-2">
    
    
        <a class="badge rounded-pill text-uppercase text-bg-secondary" href="/tags/kernel/">Kernel</a>
        <a class="badge rounded-pill text-uppercase text-bg-secondary" href="/tags/exploitation/">Exploitation</a>
  </div>

      <div class="row">
    <div class="col-md">
        
        <a href="http://localhost:1313/posts/segvroad_boilers25/">
            <span>previous: </span>
            <span>segvroad writeup - b01lers 2025</span>
        </a>
        
    </div>
    <div class="col-md text-md-end">
        
    </div>
</div>
      
    </div>
  </div>
  <footer>
    <div class="container mt-4 pb-1">
    <p class="small opacity-75">
        mowteam Â© 2026
        
        // powered by <a href="https://gohugo.io/">hugo</a> and <a href="https://github.com/imgios/not-much">imgios/not-much</a>
        
    </p>
</div>

  </footer>

  </main>

  
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js" integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz" crossorigin="anonymous"></script>
</body>
</html>
